package com.db.distribute;

import com.db.base.ConnectionBase;
import com.db.base.StatementBase;
import com.db.logic.LogicDBConnection;
import com.db.sql.ParsedSqlContext;
import com.db.sql.SQLType;
import com.db.sql.TableDistributeInfo;
import org.apache.log4j.Logger;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;

/**
 * 分布式数据库的Statement类
 * @date 2014年6月23日 上午9:56:20 
 * @version V1.0
 */
public class DistributedStatement extends StatementBase {
	public static final Logger log = Logger.getLogger(DistributedStatement.class);
	
	private String sqlExec;
	private DistributedDBRule dbRule = null;
	private ParsedSqlContext ctx = null;
	
	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		if(this.isClosed()) {
			return null;
		}
		processDbRule(sql);
		
		long beginTime = System.currentTimeMillis();
		setResultSet(plan.executeQuery());
		long endTime = System.currentTimeMillis();
		if(log.isDebugEnabled()) {
			log.debug("distributedDb(" + getDbName() + ") cost " + (endTime-beginTime) + " ms to execute sql: " + sql);
		}
		return getResultSet();
	}

	public int executeUpdateIntenal(String sql, int autoGeneratedKeys, int[] columnIndexes, 
			String[] columnNames) throws SQLException {
		if(this.isClosed()) {
			return -1;
		}
		long beginTime = System.currentTimeMillis();
		this.processDbRule(sql);
		int result =  plan.executeUpdate(autoGeneratedKeys,columnIndexes,columnNames);
		long endTime = System.currentTimeMillis();
		if(log.isDebugEnabled()) {
			log.debug("distributedDb(" + getDbName() + ") cost " + (endTime-beginTime) + " ms to execute sql: " + sql);
			log.debug(result + " records were updated.");
		}
		return result;
	}
	
	@Override
	public int[] executeBatch() throws SQLException {
		if(this.isClosed()) {
			return null;
		}
		this.processDbRule(null);
		if(log.isTraceEnabled()) {
			log.trace("dbName:" + getDbName());
		}
		Connection conn = getRealConnection(dbName);
		try (Statement state = conn.createStatement()) {
			manager.addStatement(state);
			if (batchSql == null || batchSql.size() == 0) {
				return null;
			}
			for (String sql : batchSql) {
				state.addBatch(sql);
			}
			long beginTime = System.currentTimeMillis();
			int[] result = state.executeBatch();
			long endTime = System.currentTimeMillis();
			if (log.isDebugEnabled()) {
				log.debug("distributedDb(" + getDbName() + ") cost " + (endTime - beginTime) + " ms to execute batch sql");
			}
			return result;
		}
	}
	
	public boolean executeInternal(String sql, int autoGeneratedKeys, int[] columnIndexes, 
			String[] columnNames) throws SQLException {
		if(this.isClosed()) {
			return false;
		}
		String sqlType = SQLType.getSqlType(sql);
		if(SQLType.SELECT.equals(sqlType)) {
			executeQuery(sql);
			return true;
		}else if(SQLType.INSERT.equals(sqlType) || SQLType.UPDATE.equals(sqlType) || SQLType.DELETE.equals(sqlType)) {
			if(autoGeneratedKeys != -1) {
				executeUpdate(sql, autoGeneratedKeys);
			}else if(columnIndexes != null) {
				executeUpdate(sql, columnIndexes);
			}else if(columnNames != null) {
				executeUpdate(sql, columnNames);
			}else {
				executeUpdate(sql);
			}
			return true;
		}else {
			throw new SQLException("unsupported sql");
		}
	}
	
	protected void processDbRule(String sql)  throws SQLException{
		ctx = getDbRule().getParsedSqlContext(sql, null);
		if(ctx == null) {
			throw new SQLException("getParsedSqlContext failed");
		}
		List<TableDistributeInfo> ret = getDbRule().parseSql(sql, null, ctx);
		if(ret != null) {
			plan = new SqlExecPlan();
			plan.setDistributeInfoList(ret);
			plan.setManager(getManager());
			plan.setPrepared(false);
			plan.setSql(sql);
			plan.setStatement(this);
			plan.setCtx(ctx);
			plan.setDbType(this.getDbRule().getDbType());
		}
	}

	public Connection getRealConnection(String dbName) throws SQLException {
		if(this.isClosed()) {
			return null;
		}
		LogicDBConnection conn = (LogicDBConnection)manager.getConnection(dbName, DistributedDataSource.logicDBMap.get(dbName));
//		if(conn == null) {
//			LogicDBDataSource ds = DistributedDataSource.logicDBMap.get(dbName);
//			conn = (LogicDBConnection)ds.getConnection();
//			manager.addConnection(dbName, conn);
//			
//			if(log.isTraceEnabled()) {
//				log.trace("get new connection from  db: " + this.getDbName());
//			}
//		} else {
//			if(log.isDebugEnabled()) {
//				log.trace("get connection from connection manager, db: " + this.getDbName());
//			}
//		}
		((ConnectionBase)this.getConnection()).setWrappedConnection(conn);
		conn.setReadOnly(((ConnectionBase)this.getConnection()).isReadOnly());
		conn.setAutoCommit(((ConnectionBase)this.getConnection()).getAutoCommit());
		return conn;
	}
	
	@Override
	public Connection getRealConnection() throws SQLException {
		if(this.isClosed()) {
			return null;
		}
		LogicDBConnection conn = (LogicDBConnection)manager.getConnection(dbName,DistributedDataSource.logicDBMap.get(dbName));
//		if(conn == null) {
//			LogicDBDataSource ds = DistributedDataSource.logicDBMap.get(dbName);
//			conn = (LogicDBConnection)ds.getConnection();
//			manager.addConnection(dbName, conn);
//			if(log.isTraceEnabled()) {
//				log.trace("get new connection from  db: " + this.getDbName());
//			}
//		} else {
//			if(log.isTraceEnabled()) {
//				log.trace("get connection from connection manager, db: " + this.getDbName());
//			}
//		}
		((ConnectionBase)this.getConnection()).setWrappedConnection(conn);
		conn.setReadOnly(((ConnectionBase)this.getConnection()).isReadOnly());
		conn.setAutoCommit(((ConnectionBase)this.getConnection()).getAutoCommit());
		return conn;
	}

	public String getSqlExec() {
		return sqlExec;
	}

	public void setSqlExec(String sqlExec) {
		this.sqlExec = sqlExec;
	}

	public DistributedDBRule getDbRule() {
		return dbRule;
	}

	public void setDbRule(DistributedDBRule dbRule) {
		this.dbRule = dbRule;
	}

}
